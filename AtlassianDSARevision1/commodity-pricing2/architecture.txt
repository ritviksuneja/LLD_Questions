Imagine you are given a stream of data points consisting of <timestamp, commodityPrice> you are supposed to return the maxCommodityPrice at any point in time. 
The timestamps in the stream can be out of order, or there can be duplicate timestamps, 
we need to update the commodityPrice at that particular timestamp if an entry for the timestamp already exists
Create an in-memory solution tailored to prioritize frequent reads and writes for the given problem statement


Datapoint
CommodityPrices

Datapoint:
    -timestamp: long
    -commodityPrice: double

CommodityPrices:
    -maxHeap: PriorityQueue<Datapoint>
    -timePiceMap: Map<long, double> //we can remove the top while getting the maxcommodityprice if the entry is stale. we can check if it is stale by comparing datapoint's commodityPrice against the value for the key timestamp. keep popping until a fresh entry is found
    addCommodityPrices(List<Datapoint> inputDatapoints): void()
    getMaxCommodityPrice(): double
