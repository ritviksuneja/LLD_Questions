Ah! You want to see how Chain of Responsibility (CoR) can be applied to a logging framework. Letâ€™s go step by step.

ðŸ”¹ Current Design Recap (without CoR)

Right now, you have:

Logger (singleton) â†’ has a LoggerConfig

LoggerConfig â†’ list of LogAppenders, and a minimum log level

LogAppenders â†’ ConsoleAppender, FileAppender, etc.

LogFormatter â†’ formats LogMessage

LogMessage â†’ message + log level

The logger decides if a message should be logged based on minLogLevel and then calls all appenders.

ðŸ”¹ Applying Chain of Responsibility

Idea:

Instead of a single logger checking the log level, we create a chain of loggers.

Each logger is responsible for a particular log level (or range).

Each logger decides:

â€œCan I handle this log?â€ â†’ if yes, it processes (calls its appenders)

â€œShould I pass it to the next logger?â€ â†’ forwards to the next in chain

Use Case:

InfoLogger â†’ handles INFO logs

DebugLogger â†’ handles DEBUG logs

WarningLogger â†’ handles WARNING logs

ErrorLogger â†’ handles ERROR logs

This allows flexible routing and separation of concerns.

ðŸ”¹ Changes in Design
1. Logger Interface / Abstract Logger
abstract class AbstractLogger {
    protected LogLevel level;
    protected AbstractLogger nextLogger;
    protected LoggerConfig config;

    public void setNextLogger(AbstractLogger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void setConfig(LoggerConfig config) {
        this.config = config;
    }

    public void log(LogMessage msg) {
        if (msg.getLevel().getSeverity() >= level.getSeverity()) {
            write(msg);
        }
        if (nextLogger != null) {
            nextLogger.log(msg);
        }
    }

    protected abstract void write(LogMessage msg);
}

2. Concrete Loggers
class InfoLogger extends AbstractLogger {
    public InfoLogger() { this.level = LogLevel.INFO; }

    @Override
    protected void write(LogMessage msg) {
        for (LogAppender appender : config.getAppenders()) {
            appender.append(config.getFormatter(), msg);
        }
    }
}

class DebugLogger extends AbstractLogger {
    public DebugLogger() { this.level = LogLevel.DEBUG; }

    @Override
    protected void write(LogMessage msg) {
        for (LogAppender appender : config.getAppenders()) {
            appender.append(config.getFormatter(), msg);
        }
    }
}

// Similarly WarningLogger, ErrorLogger...

3. LoggerConfig stays mostly the same
class LoggerConfig {
    private List<LogAppender> appenders = new ArrayList<>();
    private LogFormatter formatter = new DefaultFormatter();

    public void addAppender(LogAppender appender) { appenders.add(appender); }
    public List<LogAppender> getAppenders() { return appenders; }
    public LogFormatter getFormatter() { return formatter; }
    public void setFormatter(LogFormatter formatter) { this.formatter = formatter; }
}

4. Client / Singleton Logger
class Logger {
    private static Logger instance;
    private AbstractLogger chain;

    private Logger() {
        LoggerConfig config = new LoggerConfig();
        // example appenders
        config.addAppender(new ConsoleAppender());

        // setup chain
        AbstractLogger infoLogger = new InfoLogger();
        AbstractLogger debugLogger = new DebugLogger();
        AbstractLogger warningLogger = new WarningLogger();
        AbstractLogger errorLogger = new ErrorLogger();

        infoLogger.setConfig(config);
        debugLogger.setConfig(config);
        warningLogger.setConfig(config);
        errorLogger.setConfig(config);

        infoLogger.setNextLogger(debugLogger);
        debugLogger.setNextLogger(warningLogger);
        warningLogger.setNextLogger(errorLogger);

        this.chain = infoLogger;
    }

    public static Logger getInstance() {
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }

    public void log(LogMessage msg) {
        chain.log(msg);
    }
}

ðŸ”¹ How It Works

Client calls:

Logger logger = Logger.getInstance();
logger.log(new LogMessage("This is info", LogLevel.INFO));
logger.log(new LogMessage("This is error", LogLevel.ERROR));


The message enters the chain:

Each logger decides if it should handle it.

Then passes it to the next logger.

Flexible: you can reorder loggers, skip some, or even add specialized loggers (e.g., EmailLogger for ERROR only).

ðŸ”¹ Design Patterns Used

Strategy â†’ LogFormatter is a pluggable strategy for formatting logs.

Singleton â†’ Logger is singleton.

Chain of Responsibility â†’ multiple loggers (InfoLogger â†’ DebugLogger â†’ WarningLogger â†’ ErrorLogger).

ðŸ”¹ Benefits of CoR here

Decouples logging levels from the Logger class.

Easy to add new loggers (like EmailLogger for critical logs).

Each logger focuses on its responsibility (Info, Debug, etc.).

Can combine with multiple appenders per logger easily.

If you want, I can draw a class diagram showing Logger, AbstractLogger, ConcreteLoggers, LoggerConfig, Appenders, Formatter in the Chain of Responsibility style â€” that would make it really visual and easier to compare with the solved example.

Do you want me to do that?